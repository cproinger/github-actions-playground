name: Parallel Feature Releases

on:
  push:
    branches:
      - 'main'
      - 'master'
      - 'feature/**' # Triggers on any branch inside the feature/ folder

permissions:
  contents: write # Required to push tags back to the repo

jobs:
  calculate-and-tag:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version_step.outputs.version }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          # fetch-depth: 0 is CRITICAL. 
          # By default, actions only fetch the last commit. 
          # We need full history to find the last Git tag and analyze logs.
          fetch-depth: 0

      - name: Calculate Version
        id: version_step
        run: |
          # 1. Get the latest Git tag. Default to p0.0.0 if none exists.
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "p0.0.0")
          echo "Latest Tag: $LATEST_TAG"
          
          # 2. Get the current branch name
          RAW_BRANCH_NAME=${GITHUB_REF#refs/heads/}
          SAFE_BRANCH_NAME=$(echo "$RAW_BRANCH_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9._-]/-/g')
          
          # 3. Construct the Version
          if [[ "$RAW_BRANCH_NAME" == "main" ]]; then
            echo "On main branch - analyzing commits for SemVer bump..."
            
            # Get commit subjects since the last tag
            COMMITS=$(git log "$LATEST_TAG"..HEAD --format="%s")
            # Get commit bodies (for BREAKING CHANGE footer)
            BODIES=$(git log "$LATEST_TAG"..HEAD --format="%b")
            
            # Default to patch (safest assumption for any merge to main)
            BUMP_TYPE="patch"
            
            # LOGIC: Check for Major > Minor > Patch
            # 1. Major: "BREAKING CHANGE" in body or "!:" in subject (e.g., feat!: remove api)
            if echo "$BODIES" | grep -q "BREAKING CHANGE" || echo "$COMMITS" | grep -qE "^[a-z]+!:"; then
              BUMP_TYPE="major"
            # 2. Minor: "feat:" in subject
            elif echo "$COMMITS" | grep -qE "^feat(\(.*\))?:"; then
              BUMP_TYPE="minor"
            fi
            
            echo "Detected bump type: $BUMP_TYPE"
            
            # PARSE: Extract numbers from p1.2.3
            # Remove 'p' prefix and any suffixes (like -beta.1) for calculation
            CLEAN_VER=${LATEST_TAG#p}       # 1.2.3-beta.1
            CLEAN_VER=${CLEAN_VER%%-*}      # 1.2.3 (Base version)
            
            IFS='.' read -r major minor patch <<< "$CLEAN_VER"
            
            # CALCULATE: Increment numbers
            if [[ "$BUMP_TYPE" == "major" ]]; then
              major=$((major + 1))
              minor=0
              patch=0
            elif [[ "$BUMP_TYPE" == "minor" ]]; then
              minor=$((minor + 1))
              patch=0
            else
              patch=$((patch + 1))
            fi
            
            NEW_VERSION="p$major.$minor.$patch"
            echo "Bumping main to: $NEW_VERSION"
            
          else
            # STRATEGY: Parallel Prerelease
            # Format: [BaseTag]-[SanitizedBranch].[RunNumber]
            NEW_VERSION="${LATEST_TAG}-${SAFE_BRANCH_NAME}.${{ github.run_number }}"
          fi
          
          echo "Final Version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"

      - name: Create Git Tag
        # Only tag if it's a new calculated version
        run: |
          NEW_VER="${{ steps.version_step.outputs.version }}"
          
          # check if tag exists (to prevent erroring on double-runs)
          if git rev-parse "$NEW_VER" >/dev/null 2>&1; then
            echo "Tag $NEW_VER already exists. Skipping."
          else
            echo "Tagging commit with $NEW_VER"
            git config user.name "GitHub Actions"
            git config user.email "actions@github.com"
            git tag -a "$NEW_VER" -m "Automated release for $NEW_VER"
            git push origin "$NEW_VER"
          fi

  # Example of how to use this version in a build step
  build-and-release:
    needs: calculate-and-tag
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Mock Build Artifact
        run: |
          VERSION="${{ needs.calculate-and-tag.outputs.new_version }}"
          echo "Building artifact version: $VERSION"